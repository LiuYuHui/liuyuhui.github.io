<!DOCTYPE html>
<html lang="default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liuyuhui.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="The Rule of There,Five And Zero">
<meta property="og:type" content="article">
<meta property="og:title" content="The rule of cpp">
<meta property="og:url" content="http://liuyuhui.github.io/2017/03/23/The-rule-of-cpp/index.html">
<meta property="og:site_name" content="progress">
<meta property="og:description" content="The Rule of There,Five And Zero">
<meta property="article:published_time" content="2017-03-23T13:31:48.000Z">
<meta property="article:modified_time" content="2020-07-27T02:30:40.267Z">
<meta property="article:author" content="liuyuhui">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://liuyuhui.github.io/2017/03/23/The-rule-of-cpp/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>

  <title>The rule of cpp | progress</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">progress</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">I'd rather be anything but ordinary</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://liuyuhui.github.io/2017/03/23/The-rule-of-cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liuyuhui">
      <meta itemprop="description" content="This is my blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="progress">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          The rule of cpp
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-03-23 21:31:48" itemprop="dateCreated datePublished" datetime="2017-03-23T21:31:48+08:00">2017-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-27 10:30:40" itemprop="dateModified" datetime="2020-07-27T10:30:40+08:00">2020-07-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="The-Rule-of-There-Five-And-Zero"><a href="#The-Rule-of-There-Five-And-Zero" class="headerlink" title="The Rule of There,Five And Zero"></a>The Rule of There,Five And Zero</h1><a id="more"></a>

<h2 id="Attention-The-original-artices-at-stackoverflow"><a href="#Attention-The-original-artices-at-stackoverflow" class="headerlink" title="Attention: The original artices at stackoverflow."></a>Attention: The original artices at <a href="http://stackoverflow.com/documentation/c%2b%2b/1206/the-rule-of-three-five-and-zero/9867/rule-of-three#t=201607251426414241612" target="_blank" rel="noopener">stackoverflow</a>.</h2><h2 id="The-Rule-of-There"><a href="#The-Rule-of-There" class="headerlink" title="The Rule of There"></a>The Rule of There</h2><p>The Rule of Three states that if a type ever needs to have a user-defined copy constructor, copy assignment operator, or destructor, then it must have all three.<br>The reason for the rule is that a class which needs any of the three manages some resource (file handles, dynamically allocated memory, etc), and all three are needed to manage that resource consistently. The copy functions deal with how the resource gets copied between objects, and the destructor would destroy the resource, in accord with RAII principles.</p>
<p>Consider a type that manages a string resource:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">char</span> <span class="keyword">const</span>* new_name, <span class="keyword">int</span> new_age)</span><br><span class="line">        : name(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(new_name) + <span class="number">1</span>])</span><br><span class="line">        , age(new_age)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">strcpy</span>(name, new_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Since name was allocated in the constructor, the destructor deallocates it to avoid leaking memory. But what happens if such an object is copied?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"foo"</span>, <span class="number">11</span>)</span></span>;</span><br><span class="line">    Person p2 = p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>First, p1 will be constructed. Then p2 will be copied from p1. However, the C++-generated copy constructor will copy each component of the type as-is. Which means that p1.name and p2.name both point to the same string.</p>
<p>When main ends, destructors will be called. First p2’s destructor will be called; it will delete the string. Then p1’s destructor will be called. However, the string is already deleted. Calling delete on memory that was already deleted yields undefined behavior.</p>
<p>To avoid this, it is necessary to provide a suitable copy constructor. One approach is to implement a reference counted system, where different Person instances share the same string data. Each time a copy is performed, the shared reference count is incremented. The destructor then decrements the reference count, only releasing the memory if the count is zero.</p>
<p>Or we could implement value semantics and deep copying behavior:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Person(Person <span class="keyword">const</span>&amp; other)</span><br><span class="line">    : name(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(other.name) + <span class="number">1</span>])</span><br><span class="line">    , age(other.age)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(name, other.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person &amp;<span class="keyword">operator</span>=(Person <span class="keyword">const</span>&amp; other) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use copy and swap idiom to implement assignment</span></span><br><span class="line">    Person copy(other);</span><br><span class="line">    swap(copy);            <span class="comment">//  assume swap() exchanges contents of *this and copy</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Implementation of the copy assignment operator is complicated by the need to release an existing buffer. The copy and swap technique creates a temporary object which holds a new buffer. Swapping the contents of *this and copy gives ownership to copy of the original buffer. Destruction of copy, as the function returns, releases the buffer previously owned by *this.</p>
<h2 id="The-Rule-of-Five"><a href="#The-Rule-of-Five" class="headerlink" title="The Rule of Five"></a>The Rule of Five</h2><p>C++11 introduces two new special member functions: the move constructor and the move assignment operator. For all the same reasons that you want to follow the Rule of Three in C++03, you usually want to follow the Rule of Five in C++11: If a class requires ONE of five special member functions, and if move semantics are desired, then it most likely requires ALL FIVE of them.</p>
<p>Note, however, that failing to follow the Rule of Five is usually not considered an error, but a missed optimisation opportunity, as long as the Rule of Three is still followed. If no move constructor or move assignment operator is available when the compiler would normally use one, it will instead use copy semantics if possible, resulting in a less efficient operation due to unnecessary copy operations. If move semantics aren’t desired for a class, then it has no need to declare a move constructor or assignment operator.</p>
<p>Same example as for the Rule of Three:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Destructor </span></span><br><span class="line">    ~Person() &#123; <span class="keyword">delete</span> [] name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implement Copy Semantics</span></span><br><span class="line">    Person(Person <span class="keyword">const</span>&amp; other)</span><br><span class="line">        : name(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(other.name) + <span class="number">1</span>])</span><br><span class="line">        , age(other.age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(name, other.name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Person &amp;<span class="keyword">operator</span>=(Person <span class="keyword">const</span>&amp; other) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Use copy and swap idiom to implement assignment.</span></span><br><span class="line">        Person copy(other);</span><br><span class="line">        swap(*<span class="keyword">this</span>, copy);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implement Move Semantics</span></span><br><span class="line">    <span class="comment">// Note: It is usually best to mark move operators as noexcept</span></span><br><span class="line">    <span class="comment">//       This allows certain optimizations in the standard library</span></span><br><span class="line">    <span class="comment">//       when the class is used in a container.</span></span><br><span class="line"></span><br><span class="line">    Person(Person&amp;&amp; that) <span class="keyword">noexcept</span></span><br><span class="line">        : name(<span class="literal">nullptr</span>)               <span class="comment">// Set the state so we know it is undefined</span></span><br><span class="line">        , age(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(*<span class="keyword">this</span>, that);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>=(Person&amp;&amp; that) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        swap(*<span class="keyword">this</span>, that);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Person&amp; lhs, Person&amp; rhs)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(lhs.name, rhs.name);</span><br><span class="line">        <span class="built_in">std</span>::swap(lhs.age, rhs.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Alternatively, both the copy and move assignment operator can be replaced with a single assignment operator, which takes an instance by value instead of reference or rvalue reference to facilitate using the copy-and-swap idiom.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person&amp; <span class="keyword">operator</span>=(Person copy)</span><br><span class="line">&#123;</span><br><span class="line">    swap(*<span class="keyword">this</span>, copy);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Extending from the Rule of Three to the Rule of Five is important for performance reasons, but is not strictly necessary in most cases. Adding the copy constructor and assignment operator ensures that moving the type will not leak memory (move-constructing will simply fall back to copying in that case), but will be performing copies that the caller probably did not anticipate.</p>
<h2 id="The-Rule-of-Zero"><a href="#The-Rule-of-Zero" class="headerlink" title="The Rule of Zero"></a>The Rule of Zero</h2><p>We can combine the principles of the Rule of Five and RAII to get a much leaner interface: the Rule of Zero: any resource that needs to be managed should be in its own type. That type would have to follow the Rule of Five, but all users of that resource do not need to write any of the five special member functions and can simply default all of them.</p>
<p>Using the Person class introduced in the Rule of Three example, we can create a resource-managing object for cstrings:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cstring</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~cstring() &#123; <span class="keyword">delete</span> [] p; &#125;</span><br><span class="line">    cstring(cstring <span class="keyword">const</span>&amp; );</span><br><span class="line">    cstring(cstring&amp;&amp; );</span><br><span class="line">    cstring&amp; <span class="keyword">operator</span>=(cstring <span class="keyword">const</span>&amp; );</span><br><span class="line">    cstring&amp; <span class="keyword">operator</span>=(cstring&amp;&amp; );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* other members as appropriate */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>And once this is separate, our Person class becomes far simpler:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    cstring name;</span><br><span class="line">    <span class="keyword">int</span> arg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Person() = <span class="keyword">default</span>;</span><br><span class="line">    Person(Person <span class="keyword">const</span>&amp; ) = <span class="keyword">default</span>;</span><br><span class="line">    Person(Person&amp;&amp; ) = <span class="keyword">default</span>;</span><br><span class="line">    Person&amp; <span class="keyword">operator</span>=(Person <span class="keyword">const</span>&amp; ) = <span class="keyword">default</span>;</span><br><span class="line">    Person&amp; <span class="keyword">operator</span>=(Person&amp;&amp; ) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* other members as appropriate */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The special members in Person do not even need to be declared explicitly; the compiler will default or delete them appropriately, based on the contents of Person. Therefore, the following is also an example of the rule of zero.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    cstring name;</span><br><span class="line">    <span class="keyword">int</span> arg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>If cstring were to be a move-only type, with a deleted copy constructor/assignment operator, then Person would automatically be move-only as well.</p>
<p>The term rule of zero was introduced by R. Martinho Fernandes</p>
<h1 id="————这才是本体————"><a href="#————这才是本体————" class="headerlink" title="————这才是本体————-"></a>————这才是本体————-</h1><p>上面是在stackoverflow发现的c++类编写原则，the rule of there说白了就是浅拷贝(shallow copy)，深拷贝(deep copy),the rule of five添加了c++11的move constructor 和 assignment operator,the rule of zero 就是让类中的成员都有the rule of five的每个操作．</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/03/13/C-variadic-template/" rel="prev" title="C++ variadic template">
      <i class="fa fa-chevron-left"></i> C++ variadic template
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/04/29/%E6%9C%80%E5%A4%A7M%E5%AD%90%E6%AE%B5%E5%92%8C/" rel="next" title="最大M子段和">
      最大M子段和 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#The-Rule-of-There-Five-And-Zero"><span class="nav-number">1.</span> <span class="nav-text">The Rule of There,Five And Zero</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Attention-The-original-artices-at-stackoverflow"><span class="nav-number">1.1.</span> <span class="nav-text">Attention: The original artices at stackoverflow.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Rule-of-There"><span class="nav-number">1.2.</span> <span class="nav-text">The Rule of There</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Rule-of-Five"><span class="nav-number">1.3.</span> <span class="nav-text">The Rule of Five</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Rule-of-Zero"><span class="nav-number">1.4.</span> <span class="nav-text">The Rule of Zero</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#————这才是本体————"><span class="nav-number">2.</span> <span class="nav-text">————这才是本体————-</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liuyuhui</p>
  <div class="site-description" itemprop="description">This is my blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liuyuhui</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
